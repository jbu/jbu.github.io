<!doctype html><html lang=en-us><head><title>James Uther - Expanding Reducers</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content="When playing with a new bit of language, it can be helpful to restrict the problem space to an old, well understood algorithm. For me at least, learning one thing at a time is easier! For this post, It’ll be prime sieves, and I’ll be exploring clojure reducers.
A quick recap, the sieve of eratosthenes is a not-maximally-non-optimal way of finding primes. It’s usually expressed as follows:
To find primes below n: generate a list of n integers greater than 1 "><link rel=canonical href=https://uther.wtf/blog/expanding-reducers/><link rel=icon type=image/x-icon href=https://uther.wtf/favicon/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.css><link rel=stylesheet href=https://unpkg.com/purecss@2.0.6/build/pure-min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.css><link rel=stylesheet href=https://uther.wtf/css/hugo-tufte.min.css><link rel=stylesheet href=https://uther.wtf/css/hugo-tufte-override.css></head><body><div id=layout class=pure-g><article class=pure-u-1><header class=brand><a href=https://uther.wtf><h1>James Uther</h1></a><h2>Musings mostly on software engineering.</h2><nav class=menu><ul><li><a href=https://uther.wtf/><i class="fas fa-home la-lg"></i>Home</a></li><li><a href=https://uther.wtf/blog><i class="fas fa-book fa-lg"></i> blog</a></li><li><a href=https://uther.wtf/cv><i class="fas fa-info-circle fa-lg"></i> Curriculum vitae</a></li></ul></nav><hr></header><section><h1 class=content-title><a href=https://uther.wtf/blog/expanding-reducers/>Expanding Reducers</a></h1></section><section><p>When playing with a new bit of language, it can be helpful to restrict the problem space to an old, well understood algorithm. For me at least, learning one thing at a time is easier! For this post, It’ll be prime sieves, and I’ll be exploring clojure reducers.</p><p>A quick recap, the sieve of eratosthenes is a not-maximally-non-optimal way of finding primes. It’s usually expressed as follows:</p><p>To find primes below n: generate a list of n integers greater than 1</p><pre><code>while the list is not empty: 
  take the head of the list: 
    add it to the output 
    remove all numbers evenly divisible by it from the list
</code></pre><p>In clojure, something like:</p><pre><code class=language-clojure>(defn sieve 
    ([n] (sieve [] (range 2 n))) 
    ([primes xs]
        (if-let [prime (first xs)] 
            (recur (conj primes prime)
                   (remove #(zero? (mod % prime)) xs))
            primes
        )
    )
) 

(sieve 10)
;= [2 3 5 7]
</code></pre><p>Which is fine, but I’d like it lazy so I only pay for what I use, and I can use as much as I’m willing to pay for. Let’s look at lazy sequences. Luckily for us, there is an example of exactly this on the lazy-seq documentation, which we slightly modify like so:</p><pre><code class=language-clojure>(defn lazy-sieve [s] 
  (cons (first s) 
    (lazy-seq 
      (lazy-sieve (remove #(zero? (mod % (first s))) (rest s))))))
(defn primes [] 
  (lazy-seq (lazy-sieve (iterate inc 2))))

(take 5 (primes)) 
;= (2 3 5 7)
</code></pre><p>So now we have a nice generic source of primes that grows only as we take more. But is there another way?</p><p>A few months ago Rich Hickey introduced reducers. By turning the concept of ‘reducing’ inside out the new framework allows a parallel reduce (fold) in some circumstances. Which doesn’t apply here. But let’s see if we can build a different form of sieve using the new framework. First a quick overview (cribbing from the original blog post):</p><blockquote><p>Collections are now <em>reducible</em>, in that they implement a <code>reduce</code> protocol. <code>Filter</code>, <code>map</code>, etc are implemented as functions that
can be applied by a reducible to itself to return another reducible, but lazily, and possibly in parallel. So in the example
below we have a reducible (a vector), that maps inc to itself to return a reducible that is then wrapped with a filter on
<code>even?</code> which returns a further reducible, that reduce then collects with <code>+</code>.</p></blockquote><pre><code class=language-clojure>(require '[clojure.core.reducers :as r])
; We’ll be referring to r here and there – just remember it’s the clojure.core.reducers namespace

(reduce + (r/filter even? (r/map inc [1 1 1 2])))
;= 6
</code></pre><p>These are composable, so we can build ‘recipes’.</p><pre><code class=language-clojure>;;red is a reducer awaiting a collection
(def red (comp (r/filter even?) (r/map inc)))
(reduce + (red [1 1 1 2]))
;= 6
</code></pre><p><code>into</code> uses reduce internally, so we can use it to build collections instead of reducing:</p><pre><code class=language-clojure>(into [] (r/filter even? (r/map inc [1 1 1 2])))
;= [2 2 2]
</code></pre><p>So here’s the core of ‘reducer’, which</p><blockquote><p>Given a reducible collection, and a transformation function <code>xf</code>, returns a reducible collection, where any supplied reducing <strong>fn</strong> will be transformed by <code>xf</code>. <code>xf</code> is a function of reducing <strong>fn</strong> to reducing <strong>fn</strong>.</p></blockquote><pre><code class=language-clojure>(defn reducer ([coll xf] 
  (reify clojure.core.protocols/CollReduce 
    (coll-reduce [_ f1 init] (clojure.core.protocols/coll-reduce coll (xf f1) init)))))
</code></pre><p>And we can then use that to implement mapping as so:</p><pre><code class=language-clojure>(defn mapping [f] 
  (fn [f1] (fn [result input] (f1 result (f input))))) 
  
(defn rmap [f coll] (reducer coll (mapping f))) 
(reduce + 0 (rmap inc [1 2 3 4]))
;= 14
</code></pre><p>Fine. So what about sieves? One thought is we could build up a list of composed filters, built as new primes are found (see the <code>lazy-seq</code> example above). But there’s no obvious place to do the building, as applying the reducing functions is left to the reducible implementation. Another possibility is to introduce a new type of reducing function, the ‘progressive-filter’, which keeps track of past finds and can filter against them.</p><pre><code class=language-clojure>(defn prog-filter [f] 
    (let [flt (atom [])] 
        (fn [f1] (fn [result input]
            (if (not-any? #(f input %) @flt)
                (do (swap! flt conj input) 
                    (f1 result input))
                result)))))

(defn progressive-filter [f coll] 
    (reducer coll (prog-filter f)))
</code></pre><p>And we then reduce with a filtering function that is a function of the current candidate and one of the list of found primes (see the <code>#(f input %)</code> bit above)</p><pre><code class=language-clojure>(into [] (progressive-filter #(zero? (mod %1 %2)) (range 2 10)))
;= [2 3 5 7]
</code></pre><p>It’s nicely lazy, so we can use iterate to generate integers, and take only a few (<code>r/take</code>, as it’s operating on a reducer):</p><pre><code class=language-clojure>(into [] (r/take 5 (progressive-filter #(zero? (mod %1 %2)) (iterate inc 2)))) 
;= [2 3 5 7 11]
</code></pre><p>Or even</p><pre><code class=language-clojure>(def primes 
    (progressive-filter #(zero? (mod %1 %2)) (iterate inc 2)))

(into [] (r/take 5 primes))
;= [2 3 5 7 11]
</code></pre><p>You get the idea.</p><p>(Originally <a href=http://web.archive.org/web/20161006154511/http://www.lshift.net/blog/2013/07/31/expanding-reducers/>http://web.archive.org/web/20161006154511/http://www.lshift.net/blog/2013/07/31/expanding-reducers/</a>)</p></section><section><footer class=page-footer><hr><div class=previous-post style=display:inline-block></div><div class=next-post , style=display:inline-block;float:right><a class=link-reverse href="https://uther.wtf/blog/codemesh-day-1/?ref=footer">Codemesh Day 1 »</a></div><ul class=page-footer-menu><li><a href=https://twitter.com/hemul><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://github.com/jbu><i class="fab fa-github fa-lg"></i></a></li><li><a href="https://scholar.google.com/citations?user=AquEEvUAAAAJ"><i class="fas fa-graduation-cap la-lg"></i></a></li></ul><div class=copyright><p>&copy; 2022
James Uther.
All rights reserved.</p></div></footer></section></article></div></body></html>